from Problem import *
import random
from typing import Tuple, List


class NPuzzleProblem(Problem):
    def __init__(self, n: int, initial_state: Tuple[int, ...] = None):
        self.n = n
        self.goal = tuple(range(1, n * n)) + (0,)
        if initial_state:
            self.initial = initial_state
        else:
            self.initial = self._generate_solvable_puzzle()

    def initial_state(self) -> Tuple[int, ...]:
        return self.initial

    def actions(self, state: Tuple[int, ...]) -> List[str]:
        index = state.index(0)
        row, col = divmod(index, self.n)
        # Generate legal moves
        valid_actions = []
        if row > 0: valid_actions.append('UP')
        if row < self.n - 1: valid_actions.append('DOWN')
        if col > 0: valid_actions.append('LEFT')
        if col < self.n - 1: valid_actions.append('RIGHT')
        return valid_actions

    def result(self, state: Tuple[int, ...], action: str) -> Tuple[int, ...]:
        index = state.index(0)
        row, col = divmod(index, self.n)
        new_row, new_col = row, col
        if action == 'UP':
            new_row -= 1
        elif action == 'DOWN':
            new_row += 1
        elif action == 'LEFT':
            new_col -= 1
        elif action == 'RIGHT':
            new_col += 1
        new_index = new_row * self.n + new_col
        state_list = list(state)
        state_list[index], state_list[new_index] = state_list[new_index], state_list[index]
        return tuple(state_list)

    def goal_test(self, state: Tuple[int, ...]) -> bool:
        return state == self.goal

    def step_cost(self, state: Tuple[int, ...], action: str) -> float:
        return 1

    def hash_state(self, state: Tuple[int, ...]) -> int:
        return hash(state)

    def is_valid(self, state: Tuple[int, ...]) -> bool:
        # Since all states generated by legal moves are valid, we return True
        return True

    def _generate_solvable_puzzle(self) -> Tuple[int, ...]:
        while True:
            tiles = list(range(self.n * self.n))
            random.shuffle(tiles)
            if self._is_solvable(tiles):
                return tuple(tiles)

    def _is_solvable(self, tiles: List[int]) -> bool:
        inv_count = 0
        for i in range(len(tiles)):
            for j in range(i + 1, len(tiles)):
                if tiles[i] != 0 and tiles[j] != 0 and tiles[i] > tiles[j]:
                    inv_count += 1
        if self.n % 2 == 1:
            return inv_count % 2 == 0
        else:
            zero_row = tiles.index(0) // self.n
            return (inv_count + zero_row) % 2 == 0
